
-- tb_cargo
CREATE TABLE tb_cargos (
id_cargo NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
no_nome VARCHAR2(100) NOT NULL UNIQUE,
nu_salario NUMBER(9) NOT NULL,
CONSTRAINT ck_salario_valido CHECK (nu_salario > 0)
);

-- Procedures e functions
CREATE OR REPLACE PROCEDURE atualizar_salario_cargo (
    p_id_cargo IN NUMBER,
    p_salario IN NUMBER 
)
IS
BEGIN
    UPDATE tb_cargos SET nu_salario = p_salario 
    WHERE  id_cargo = p_id_cargo;
    
EXCEPTION
    WHEN OTHERS THEN
        -- tratamento de erro
        RAISE_APPLICATION_ERROR(-20001, 'Erro ao atualizar salario do cargo: ' || SQLERRM);
END;
/

-- Retorna o id associado ao nome de um cargo
CREATE OR REPLACE FUNCTION get_id_cargo (
     p_no_cargo VARCHAR2
)
RETURN NUMBER
IS
    r_id_cargo NUMBER(9);
BEGIN
    SELECT id_cargo INTO r_id_cargo FROM tb_cargos WHERE no_nome = p_no_cargo;    
    RETURN r_id_cargo;  
END;
/

-- == TB_PESSOAS
CREATE TABLE tb_pessoas (
    id_pessoa NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    no_nome VARCHAR2(100) NOT NULL,
    no_email VARCHAR2(50) NOT NULL,
    no_cep VARCHAR2(9) NOT NULL,
    no_cidade VARCHAR2(50) NOT NULL,
    no_endereco VARCHAR2(200) NOT NULL, -- TODO: oportunidade de normalizacao
    no_pais VARCHAR2(50) NOT NULL,
    no_usuario VARCHAR2(50) NOT NULL,
    no_telefone VARCHAR2(15) NOT NULL,
    dt_data_nascimento DATE NOT NULL,
    id_cargo NUMBER NOT NULL,
    -- Constraints nomeadas
    CONSTRAINT fk_cargo
     FOREIGN KEY (id_cargo)
     REFERENCES tb_cargos(id_cargo)
     ON DELETE CASCADE,
    -- Validacao supondo estrutura do registro (xx) xxxx-xxxx
    CONSTRAINT ck_telefone_valido CHECK (REGEXP_LIKE(no_telefone, '^\([0-9]{2}\) [0-9]{4}-[0-9]{4}$')),
    -- Validacao supondo estrutura xxxxx-xxx
    CONSTRAINT ck_cep_valido CHECK (REGEXP_LIKE(no_cep, '^[0-9]{5}-[0-9]{3}$'))
);

-- Popular tabela


-- Functions e procedures auxiliares
CREATE OR REPLACE FUNCTION get_no_cargo_pessoa (
     p_id_pessoa NUMBER
)
RETURN VARCHAR2
IS
    r_cargo VARCHAR2(100);
BEGIN
    SELECT cargos.no_nome INTO r_cargo FROM tb_pessoas pessoas INNER JOIN tb_cargos cargos ON
    pessoas.id_cargo = cargos.id_cargo WHERE p_id_pessoa = pessoas.id_pessoa;    
    RETURN r_cargo;  
END;
/
CREATE OR REPLACE FUNCTION get_nu_salario_pessoa (
     p_id_pessoa NUMBER
)
RETURN NUMBER
IS
    r_salario NUMBER(9);
BEGIN
    SELECT cargos.nu_salario INTO r_salario FROM tb_pessoas pessoas INNER JOIN tb_cargos cargos ON
    pessoas.id_cargo = cargos.id_cargo WHERE p_id_pessoa = pessoas.id_pessoa;    
    RETURN r_salario;  
END;
/
-- CRUD
CREATE OR REPLACE FUNCTION get_pessoas_paginado(
    p_pag_tamanho        IN NUMBER,        -- Número de registros por página
    p_pag_numero         IN NUMBER,        -- Número da página atual
    p_criterio_ordenacao IN VARCHAR2 DEFAULT 'id'
) RETURN SYS_REFCURSOR IS
    r_cursor SYS_REFCURSOR;
    v_consulta    VARCHAR2(1000);    
    v_coluna VARCHAR2(30);
BEGIN
    -- Validação do critério de ordenação
    IF p_criterio_ordenacao NOT IN ('id', 'nome', 'data_nascimento') THEN
        RAISE_APPLICATION_ERROR(-20009, 'Critério de ordenação inválido: ' || p_criterio_ordenacao);
    END IF;

    -- Selecao do nome apropriado da coluna
    CASE p_criterio_ordenacao
       WHEN 'id' THEN v_coluna := 'id_pessoa';
       WHEN 'nome' THEN v_coluna := 'no_nome';
    END CASE;

    -- Consulta construida em runtime
    v_consulta := '
        SELECT *
        FROM tb_pessoas
        ORDER BY ' || v_coluna || '
        OFFSET :offset_val ROWS
        FETCH NEXT :limit_val ROWS ONLY';

    -- Executando consulta e salvando resultado no cursor
    OPEN r_cursor FOR v_consulta
        USING (p_pag_numero - 1) * p_pag_tamanho, p_pag_tamanho;
    RETURN r_cursor;
    EXCEPTION
    WHEN OTHERS THEN
        -- tratamento de erro
        RAISE_APPLICATION_ERROR(-20010, 'Erro ao consultar pessoas: ' || SQLERRM);
END;
/
CREATE OR REPLACE FUNCTION get_pessoa_por_id(
    p_id_pessoa IN NUMBER
) RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT * FROM tb_pessoas WHERE id_pessoa = p_id_pessoa;
    RETURN v_cursor;
END;
/
-- Cria novo registro de pessoa
CREATE OR REPLACE PROCEDURE create_pessoa(
    p_nome IN VARCHAR2 DEFAULT NULL,
    p_email IN VARCHAR2 DEFAULT NULL,
    p_cep IN VARCHAR2 DEFAULT NULL,
    p_cidade IN VARCHAR2 DEFAULT NULL,
    p_endereco IN VARCHAR2 DEFAULT NULL,
    p_pais IN VARCHAR2 DEFAULT NULL,
    p_usuario IN VARCHAR2 DEFAULT NULL,
    p_telefone IN VARCHAR2 DEFAULT NULL,
    p_data_nascimento IN VARCHAR2 DEFAULT NULL,
    p_no_cargo VARCHAR2 DEFAULT NULL
)
IS
    v_id_cargo NUMBER;
BEGIN
    -- Obtem o id associado ao nome do cargo
    SELECT get_id_cargo(p_no_cargo) INTO v_id_cargo FROM dual;
    INSERT INTO tb_pessoas (
    no_nome,
    no_email,
    no_cep,
    no_cidade,
    no_endereco,
    no_pais,
    no_usuario,
    no_telefone,
    dt_data_nascimento,
    id_cargo)
    VALUES (
        p_nome,
        p_email,
        p_cep,
        p_cidade,
        p_endereco,
        p_pais,
        p_usuario,
        p_telefone,
        to_date(p_data_nascimento, 'MM/DD/YYYY'),
        v_id_cargo
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20005, 'Erro ao criar pessoa: ' || SQLERRM);
END;
/
-- Deleta pessoa
CREATE OR REPLACE PROCEDURE delete_pessoa(
    p_id_pessoa IN NUMBER
    ) AS
BEGIN
  DELETE FROM tb_pessoas
  WHERE id = p_id_pessoa;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;   -- Cancelaremos o delete
    RAISE_APPLICATION_ERROR(-20020, 'Erro ao deletar pessoa: ' || SQLERRM);
END;
/

-- TODO: Solucao nao escalavel 
CREATE OR REPLACE PROCEDURE update_pessoa(
    p_id_pessoa IN NUMBER,
    p_nome IN VARCHAR2 DEFAULT NULL,
    p_email IN VARCHAR2 DEFAULT NULL,
    p_cep IN VARCHAR2 DEFAULT NULL,
    p_cidade IN VARCHAR2 DEFAULT NULL,
    p_endereco IN VARCHAR2 DEFAULT NULL,
    p_pais IN VARCHAR2 DEFAULT NULL,
    p_usuario IN VARCHAR2 DEFAULT NULL,
    p_telefone IN VARCHAR2 DEFAULT NULL,
    p_data_nascimento IN VARCHAR2 DEFAULT NULL,
    p_id_cargo IN NUMBER DEFAULT NULL
)
IS
BEGIN

    -- Atualização dos dados
    UPDATE tb_pessoas
    SET 
        no_nome            = p_nome,
        no_email           = p_email,
        no_cep             = p_cep,
        no_cidade          = p_cidade,
        no_endereco        = p_endereco,
        no_pais            = p_pais,
        no_usuario         = p_usuario,
        no_telefone        = p_telefone,
        dt_data_nascimento = TO_DATE(p_data_nascimento, 'MM/DD/YY'),
        id_cargo           = p_id_cargo
    WHERE id_pessoa = p_id_pessoa;
    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20006, 'Erro ao atualizar pessoa: ' || SQLERRM);
END;
/
-- == TB_PESSOA_SALARIO
CREATE TABLE tb_pessoa_salario (
    id_pessoa_salario NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    id_pessoa NUMBER,
    no_cargo VARCHAR2(50) NOT NULL,
    no_pessoa VARCHAR(100) NOT NULL,
    nu_salario NUMBER(9) NOT NULL, 
    CONSTRAINT fk_pessoa
     FOREIGN KEY (id_pessoa)
     REFERENCES tb_pessoas(id_pessoa)
     ON DELETE CASCADE
);

/
-- Functions e procedures

-- Criar novo registro
CREATE OR REPLACE PROCEDURE create_pessoa_salario(
    p_id_pessoa IN NUMBER 
)
IS
    v_no_pessoa VARCHAR2(100);
    v_no_cargo VARCHAR2(50);
    v_nu_salario NUMBER(9);
BEGIN
    SELECT get_no_cargo_pessoa(p_id_pessoa) INTO v_no_cargo FROM dual;
    SELECT get_nu_salario_pessoa(p_id_pessoa) INTO v_nu_salario FROM dual;
    SELECT no_nome INTO v_no_pessoa FROM tb_pessoas WHERE id_pessoa = p_id_pessoa;
    INSERT INTO tb_pessoa_salario (
        id_pessoa, no_cargo, no_pessoa, nu_salario
    ) VALUES (
        p_id_pessoa, v_no_cargo, v_no_pessoa, v_nu_salario
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20010, 'Erro ao criar registro em pessoa_salario: ' || SQLERRM);
END;
/
-- Atualizar o salario de um registro individual
CREATE OR REPLACE PROCEDURE atualizar_salario_pessoa(
    p_id_pessoa_salario IN NUMBER,
    p_salario IN NUMBER 
)
IS
BEGIN
    UPDATE tb_pessoa_salario 
    SET nu_salario = p_salario 
    WHERE id_pessoa_salario = p_id_pessoa_salario;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Erro ao atualizar salario do pessoa_salario: ' || SQLERRM);
END;

/
--/
---- Atualiza o salario de um cargo e recalcula os salarios da tabela tb_pessoa_salario
--CREATE OR REPLACE PROCEDURE recalcular_salario_cargo(
--    p_id_cargo IN NUMBER,
--    p_salario IN NUMBER 
--)
--IS
--BEGIN
--    atualizar_salario_cargo(p_id_cargo, p_salario);
--    FOR r IN (SELECT id_pessoa FROM tb_pessoa_salario) LOOP
--        atualizar_salario_pessoa(r.id_pessoa, p_salario);
--    END LOOP;
--EXCEPTION
--    WHEN OTHERS THEN
--        RAISE_APPLICATION_ERROR(-20003, 'Erro ao recalcular salario: ' || SQLERRM);
--
--END;
--/
CREATE OR REPLACE FUNCTION get_pessoa_salario_paginado(
    p_pag_tamanho        IN NUMBER,        -- Número de registros por página
    p_pag_numero         IN NUMBER,        -- Número da página atual
    p_criterio_ordenacao IN VARCHAR2 DEFAULT 'id'
) RETURN SYS_REFCURSOR IS
    r_cursor SYS_REFCURSOR;
    v_consulta    VARCHAR2(1000);    
    v_coluna VARCHAR2(30);
BEGIN
    -- Validação do critério de ordenação
    IF p_criterio_ordenacao NOT IN ('salario', 'id', 'nome', 'data_nascimento') THEN
        RAISE_APPLICATION_ERROR(-20009, 'Critério de ordenação inválido: ' || p_criterio_ordenacao);
    END IF;

    -- Selecao do nome apropriado da coluna
    CASE p_criterio_ordenacao
        WHEN 'salario' THEN v_coluna := 'nu_salario';
        WHEN 'id' THEN v_coluna := 'id_pessoa_salario';
        WHEN 'nome' THEN v_coluna := 'no_nome';
        WHEN 'data_nascimento' THEN v_coluna := 'dt_data_nascimento';
    END CASE;

    -- Consulta construida em runtime
    v_consulta := '
        SELECT *
        FROM tb_pessoa_salario
        ORDER BY ' || v_coluna || '
        OFFSET :offset_val ROWS
        FETCH NEXT :limit_val ROWS ONLY';

    -- Executando consulta e salvando resultado no cursor
    OPEN r_cursor FOR v_consulta
        USING (p_pag_numero - 1) * p_pag_tamanho, p_pag_tamanho;
    RETURN r_cursor;
    EXCEPTION
    WHEN OTHERS THEN
        -- tratamento de erro
        RAISE_APPLICATION_ERROR(-20010, 'Erro ao consultar pessoas: ' || SQLERRM);
END;
/


















